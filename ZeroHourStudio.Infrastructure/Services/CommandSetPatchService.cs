using System.Linq;
using System.Text;
using System.Text.RegularExpressions;
using ZeroHourStudio.Domain.Entities;

namespace ZeroHourStudio.Infrastructure.Services;

public class CommandSetPatchResult
{
    public bool CommandSetCreated { get; set; }
    public bool CommandButtonCreated { get; set; }
    public bool ObjectPatched { get; set; }
    public bool FactoryCommandSetUpdated { get; set; }
    public string CommandSetName { get; set; } = string.Empty;
    public string CommandButtonName { get; set; } = string.Empty;
    public string? FactoryCommandSetName { get; set; }
    public string? PatchFolder { get; set; }
}

/// <summary>
/// خدمة توليد Patch آلي للـ CommandSet/CommandButton
/// </summary>
public class CommandSetPatchService
{
    private static readonly Regex CommandSetRegex = new(@"^\s*CommandSet\s+(\w+)", RegexOptions.IgnoreCase | RegexOptions.Compiled);
    private static readonly Regex CommandButtonRegex = new(@"^\s*CommandButton\s+(\w+)", RegexOptions.IgnoreCase | RegexOptions.Compiled);

    /// <param name="targetFaction">الفصيل الهدف (إن وُجد) - إن لم يُحدد يُستخدم unit.Side</param>
    public async Task<CommandSetPatchResult> EnsureCommandSetAsync(
        SageUnit unit,
        Dictionary<string, string> unitData,
        string targetModPath,
        string? targetFaction = null)
    {
        if (string.IsNullOrWhiteSpace(targetModPath))
            throw new ArgumentNullException(nameof(targetModPath));

        var result = new CommandSetPatchResult();
        var commandSetName = unitData.TryGetValue("CommandSet", out var existingCommandSet)
            ? existingCommandSet
            : $"CommandSet_{unit.TechnicalName}";

        var realCommandSetName = await FindRealCommandSetName(targetModPath, commandSetName);
        if (!string.IsNullOrWhiteSpace(realCommandSetName))
        {
            commandSetName = realCommandSetName;
        }

        var commandButtonName = $"Command_{unit.TechnicalName}";
        result.CommandSetName = commandSetName;
        result.CommandButtonName = commandButtonName;

        var commandSetExists = await CommandSetExistsAsync(targetModPath, commandSetName);
        var commandButtonExists = await CommandButtonExistsAsync(targetModPath, commandButtonName);

        if (commandSetExists && commandButtonExists)
            return result;

        var patchFolder = Path.Combine(targetModPath, "Data", "INI", "AutoGenerated");
        Directory.CreateDirectory(patchFolder);
        result.PatchFolder = patchFolder;

        if (!commandButtonExists)
        {
            var commandButtonPath = Path.Combine(patchFolder, "CommandButton.ini");
            await AppendCommandButtonAsync(commandButtonPath, commandButtonName, unit.TechnicalName, unitData);
            result.CommandButtonCreated = true;
        }

        if (!commandSetExists)
        {
            var commandSetPath = Path.Combine(patchFolder, "CommandSet.ini");
            await AppendCommandSetAsync(commandSetPath, commandSetName, commandButtonName);
            result.CommandSetCreated = true;
        }

        if (!commandSetExists && !unitData.ContainsKey("CommandSet"))
        {
            var objectPatchPath = Path.Combine(patchFolder, "ObjectPatch.ini");
            await AppendObjectPatchAsync(objectPatchPath, unit.TechnicalName, commandSetName);
            result.ObjectPatched = true;
        }

        var factionToUse = !string.IsNullOrWhiteSpace(targetFaction) ? targetFaction : unit.Side;
        var factoryCommandSet = ResolveFactoryCommandSet(factionToUse);
        if (!string.IsNullOrWhiteSpace(factoryCommandSet))
        {
            result.FactoryCommandSetName = factoryCommandSet;
            var factoryUpdated = await AppendCommandButtonToFactoryAsync(
                targetModPath,
                patchFolder,
                factoryCommandSet,
                commandButtonName);
            result.FactoryCommandSetUpdated = factoryUpdated;
        }

        return result;
    }

    /// <summary>
    /// البحث عن الاسم الحقيقي للـ CommandSet داخل ملفات INI
    /// </summary>
    public async Task<string?> FindRealCommandSetName(string targetModPath, string commandSetName)
    {
        var iniRoot = Path.Combine(targetModPath, "Data", "INI");
        if (!Directory.Exists(iniRoot))
            return null;

        foreach (var file in Directory.GetFiles(iniRoot, "*.ini", SearchOption.AllDirectories))
        {
            var name = await FindCommandSetNameInFile(file, commandSetName);
            if (!string.IsNullOrWhiteSpace(name))
                return name;
        }

        return null;
    }

    private static async Task<string?> FindCommandSetNameInFile(string filePath, string commandSetName)
    {
        try
        {
            var lines = await File.ReadAllLinesAsync(filePath);
            foreach (var line in lines)
            {
                var match = CommandSetRegex.Match(line);
                if (match.Success && match.Groups[1].Value.Equals(commandSetName, StringComparison.OrdinalIgnoreCase))
                {
                    return match.Groups[1].Value;
                }
            }
        }
        catch
        {
            return null;
        }

        return null;
    }

    private static string? ResolveFactoryCommandSet(string side)
    {
        if (string.IsNullOrWhiteSpace(side))
            return null;
        var s = side.ToLowerInvariant();
        if (s.Contains("usa", StringComparison.Ordinal) || s.Contains("america", StringComparison.Ordinal) || s.Contains("american", StringComparison.Ordinal))
            return "CommandSetAmericaWarFactory";
        if (s.Contains("china", StringComparison.Ordinal) || s.Contains("chinanuke", StringComparison.Ordinal) || s.Contains("chinainf", StringComparison.Ordinal))
            return "CommandSetChinaWarFactory";
        if (s.Contains("gla", StringComparison.Ordinal) || s.Contains("glainf", StringComparison.Ordinal) || s.Contains("glalair", StringComparison.Ordinal) || s.Contains("glatet", StringComparison.Ordinal))
            return "CommandSetGLAWarFactory";

        return null;
    }

    private static async Task<bool> CommandSetExistsAsync(string targetModPath, string commandSetName)
    {
        var iniRoot = Path.Combine(targetModPath, "Data", "INI");
        if (!Directory.Exists(iniRoot))
            return false;

        foreach (var file in Directory.GetFiles(iniRoot, "*.ini", SearchOption.AllDirectories))
        {
            if (await ContainsDefinitionAsync(file, CommandSetRegex, commandSetName))
                return true;
        }

        return false;
    }

    private static async Task<bool> CommandButtonExistsAsync(string targetModPath, string commandButtonName)
    {
        var iniRoot = Path.Combine(targetModPath, "Data", "INI");
        if (!Directory.Exists(iniRoot))
            return false;

        foreach (var file in Directory.GetFiles(iniRoot, "*.ini", SearchOption.AllDirectories))
        {
            if (await ContainsDefinitionAsync(file, CommandButtonRegex, commandButtonName))
                return true;
        }

        return false;
    }

    private static async Task<bool> ContainsDefinitionAsync(string filePath, Regex regex, string name)
    {
        try
        {
            var lines = await File.ReadAllLinesAsync(filePath);
            foreach (var line in lines)
            {
                var match = regex.Match(line);
                if (match.Success && match.Groups[1].Value.Equals(name, StringComparison.OrdinalIgnoreCase))
                    return true;
            }
        }
        catch
        {
            return false;
        }

        return false;
    }

    private static async Task AppendCommandButtonAsync(string filePath, string commandButtonName, string unitName, Dictionary<string, string> unitData)
    {
        var builder = new StringBuilder();
        builder.AppendLine();
        builder.AppendLine($"CommandButton {commandButtonName}");
        builder.AppendLine("  Command = UNIT_BUILD");
        builder.AppendLine($"  Object = {unitName}");
        builder.AppendLine($"  TextLabel = CONTROLBAR:Construct{unitName}");
        builder.AppendLine("  ButtonBorderType = BUILD");

        if (unitData.TryGetValue("ButtonImage", out var buttonImage) && !string.IsNullOrWhiteSpace(buttonImage))
            builder.AppendLine($"  ButtonImage = {buttonImage}");
        if (unitData.TryGetValue("SelectPortrait", out var selectPortrait) && !string.IsNullOrWhiteSpace(selectPortrait))
            builder.AppendLine($"  SelectPortrait = {selectPortrait}");
        if (unitData.TryGetValue("Image", out var image) && !string.IsNullOrWhiteSpace(image))
            builder.AppendLine($"  Image = {image}");

        builder.AppendLine("End");

        await File.AppendAllTextAsync(filePath, builder.ToString(), Encoding.ASCII);
    }

    private static async Task AppendCommandSetAsync(string filePath, string commandSetName, string commandButtonName)
    {
        var builder = new StringBuilder();
        builder.AppendLine();
        builder.AppendLine($"CommandSet {commandSetName}");
        builder.AppendLine($"  1 = {commandButtonName}");
        builder.AppendLine("End");

        await File.AppendAllTextAsync(filePath, builder.ToString(), Encoding.ASCII);
    }

    private static async Task AppendObjectPatchAsync(string filePath, string unitName, string commandSetName)
    {
        var builder = new StringBuilder();
        builder.AppendLine();
        builder.AppendLine($"Object {unitName}");
        builder.AppendLine($"  CommandSet = {commandSetName}");
        builder.AppendLine("End");

        await File.AppendAllTextAsync(filePath, builder.ToString(), Encoding.ASCII);
    }

    private static async Task<bool> AppendCommandButtonToFactoryAsync(
        string targetModPath,
        string patchFolder,
        string factoryCommandSet,
        string commandButtonName)
    {
        var iniRoot = Path.Combine(targetModPath, "Data", "INI");
        if (!Directory.Exists(iniRoot))
            return false;

        var commandSetBlock = await FindCommandSetBlockAsync(iniRoot, factoryCommandSet);
        if (commandSetBlock == null)
            return false;

        var updatedBlock = AppendCommandToBlock(commandSetBlock.Lines, commandButtonName);
        if (updatedBlock == null)
            return false;

        var patchPath = Path.Combine(patchFolder, "CommandSetFactoryPatch.ini");
        await File.AppendAllTextAsync(patchPath, updatedBlock, Encoding.ASCII);
        return true;
    }

    private static async Task<CommandSetBlock?> FindCommandSetBlockAsync(string iniRoot, string commandSetName)
    {
        foreach (var file in Directory.GetFiles(iniRoot, "*.ini", SearchOption.AllDirectories))
        {
            var block = await ExtractCommandSetBlockAsync(file, commandSetName);
            if (block != null)
                return block;
        }

        return null;
    }

    private static async Task<CommandSetBlock?> ExtractCommandSetBlockAsync(string filePath, string commandSetName)
    {
        string[] lines;
        try
        {
            lines = await File.ReadAllLinesAsync(filePath);
        }
        catch
        {
            return null;
        }

        for (int i = 0; i < lines.Length; i++)
        {
            var line = lines[i].Trim();
            if (!line.StartsWith("CommandSet", StringComparison.OrdinalIgnoreCase))
                continue;

            var match = CommandSetRegex.Match(line);
            if (!match.Success || !match.Groups[1].Value.Equals(commandSetName, StringComparison.OrdinalIgnoreCase))
                continue;

            var blockLines = new List<string> { lines[i] };
            i++;
            while (i < lines.Length)
            {
                blockLines.Add(lines[i]);
                if (lines[i].Trim().Equals("End", StringComparison.OrdinalIgnoreCase))
                    break;
                i++;
            }

            return new CommandSetBlock(filePath, blockLines);
        }

        return null;
    }

    private static string? AppendCommandToBlock(List<string> lines, string commandButtonName)
    {
        var entries = new List<(int Slot, string Value)>();
        foreach (var line in lines)
        {
            var trimmed = line.Trim();
            var equalsIndex = trimmed.IndexOf('=');
            if (equalsIndex <= 0)
                continue;

            var left = trimmed.Substring(0, equalsIndex).Trim();
            if (int.TryParse(left, out var slot))
            {
                var value = trimmed.Substring(equalsIndex + 1).Trim();
                entries.Add((slot, value));
            }
        }

        if (entries.Any(e => e.Value.Equals(commandButtonName, StringComparison.OrdinalIgnoreCase)))
            return null;

        var nextSlot = entries.Count == 0 ? 1 : entries.Max(e => e.Slot) + 1;

        var builder = new StringBuilder();
        foreach (var line in lines)
        {
            if (line.Trim().Equals("End", StringComparison.OrdinalIgnoreCase))
            {
                builder.AppendLine($"  {nextSlot} = {commandButtonName}");
                builder.AppendLine("End");
                break;
            }

            builder.AppendLine(line);
        }

        return builder.ToString();
    }

    private sealed record CommandSetBlock(string FilePath, List<string> Lines);
}
